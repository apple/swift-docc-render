#!/usr/bin/env node

/* eslint-disable no-restricted-syntax, import/no-extraneous-dependencies */

const fs = require('fs');
const path = require('path');

const Parser = require('tree-sitter');
const JavaScript = require('tree-sitter-javascript');
const Vue = require('tree-sitter-vue');

async function* find(dir, predicate = () => true) {
  const files = await fs.promises.readdir(dir);

  for await (const file of files) {
    const fpath = path.join(dir, file);
    const fstat = await fs.promises.stat(fpath);

    if (fstat.isDirectory()) {
      yield* find(fpath, predicate);
    } else if (predicate(fpath)) {
      yield fpath;
    }
  }
}

async function* findVueFiles(dir) {
  const isVueFile = fpath => path.extname(fpath) === '.vue';
  yield* find(dir, isVueFile);
}

function execQuery(query, tree) {
  const capturesArray = query.captures(tree.rootNode);
  return capturesArray.reduce((obj, capture) => ({
    ...obj,
    [capture.name]: capture.node,
  }), {});
}

function createDocComment(commentNode) {
  const { text } = commentNode;

  const bodyPattern = /\/\*+\s([\s\S]*?)\s\*+\//;
  const bodyResult = bodyPattern.exec(text);
  const body = bodyResult[1].trimEnd();

  const lines = body.split('\n').map((line, i) => {
    const linePattern = /^\s*\**\s+(.*)$/d;
    const lineResult = linePattern.exec(line);
    const text = lineResult[1];
    return {
      text,
      range: {
        start: {
          line: i,
          character: lineResult.indices[1][0],
        },
        end: {
          line: i,
          character: lineResult.indices[1][1],
        },
      },
    };
  });

  return { lines };
}

(async () => {
  const vueParser = new Parser();
  vueParser.setLanguage(Vue);
  const scriptTextQuery = new Parser.Query(Vue,
    `(script_element
       (raw_text) @script)`);

  const jsParser = new Parser();
  jsParser.setLanguage(JavaScript);
  const exportNameQuery = new Parser.Query(JavaScript,
    `(
       (comment)? @comment (#match? @comment "^/[*]{2}")
       .
       (export_statement
         (object
           (pair
             (property_identifier) @key (#eq? @key "name")
             .
             (string (string_fragment) @component))))
     )`);

  const symbols = [];

  const rootDir = path.join(__dirname, '..');
  const componentsDir = path.join(rootDir, 'src/components');
  for await (const filepath of findVueFiles(componentsDir)) {
    const contents = await fs.promises.readFile(filepath, { encoding: 'utf8' });
    const vueTree = vueParser.parse(contents);

    const { script } = execQuery(scriptTextQuery, vueTree);
    if (script) {
      const jsTree = jsParser.parse(script.text);

      const captures = execQuery(exportNameQuery, jsTree);
      const { comment, component } = captures;
      if (component) {
        const pathComponents = filepath
          .replace(componentsDir, '')
          .split('/')
          .filter(part => part.length)
          .map(part => path.parse(part).name);
        const preciseIdentifier = pathComponents.join('');
        const docComment = comment ? createDocComment(comment) : null;
        symbols.push({
          accessLevel: 'public',
          identifier: {
            interfaceLanguage: 'swift', // FIXME
            precise: preciseIdentifier,
          },
          kind: {
            identifier: 'class', // FIXME
            displayName: 'Component',
          },
          names: {
            title: component.text,
          },
          pathComponents,
          docComment,
        });
      }
    }
  }

  const formatVersion = {
    major: 0,
    minor: 1,
    patch: 0,
  };
  const metadata = {
    formatVersion,
    generator: 'SwiftDocCRender',
  };
  const $module = {
    name: 'SwiftDocCRender',
    platform: {},
  };
  const relationships = [];
  const symbolGraph = {
    metadata,
    module: $module,
    relationships,
    symbols,
  };
  const symbolGraphJSON = JSON.stringify(symbolGraph);

  console.log(symbolGraphJSON);
})();
